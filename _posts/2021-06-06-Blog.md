---
layout:     post
title:      "Java基础&原理讲解篇"
subtitle:   " \"集合，反射，注解，线程\""
date:       2020-06-06 19:49:10
author:     "Jackie Xu"
header-img: "img/post-bg-20210606.jpg"
tags:
    - Java
---






## 基础语法



未整理完！！！！！！！！！！！！！！！！！！！我喜欢先把文章放上，再做整理





#### 关键字



作用

1、返回值

2、结束运行该函数

注意：一个函数的返回值类型 是void，那么也可以出现return关键字，但是return关键字的后面不能有数据。

此时return表示结束程序的运行

break、continue与return的区别：

1. break关键字是结束整个循环。
2. continue关键字是结束某次循环。
3. return关键字是结束一个函数。







#### 类型

String类型 小数 ——> int类型

```java
// 强转会报错，所以可以采用转为对应的 Double 型| Float 型，再截取整数部分

String a = "93.0";
int af = Float.valueOf(a).intValue();
System.out.println(af);// 93

String b = "93.1";
int bf = Float.valueOf(b).intValue();
System.out.println(bf);// 93

String c = "93.9";
int cf = Float.valueOf(c).intValue();
System.out.println(cf);// 93

// double 类似，Double.valueOf(str).intValue()

// TODO 看 intValue() 的源码
    /**
     * Returns the value of this {@code Float} as an {@code int} after
     * a narrowing primitive conversion.
     * @return  the {@code float} value represented by this object
     *          converted to type {@code int}
     * @jls 5.1.3 Narrowing Primitive Conversions
     */
    public int intValue() {
        return (int)value;
    }
// 这里只说明了强转，经过我上述的试验，发现只取到整数部分，无四舍五入，所以理解为截取，至于背后实际是如何操作的，不是很清楚
```





### 数组



============================================================

**那么二维数组在内存的空间地址是连续的么？**

不同编程语言的内存管理是不一样的，以C++为例，在C++中二维数组是连续分布的。

我们来做一个实验，C++测试代码如下：

```
void test_arr() {
    int array[2][3] = {
		{0, 1, 2},
		{3, 4, 5}
    };
    cout << &array[0][0] << " " << &array[0][1] << " " << &array[0][2] << endl;
    cout << &array[1][0] << " " << &array[1][1] << " " << &array[1][2] << endl;
}

int main() {
    test_arr();
}
```

测试地址为

```
0x7ffee4065820 0x7ffee4065824 0x7ffee4065828
0x7ffee406582c 0x7ffee4065830 0x7ffee4065834
```

注意地址为16进制，可以看出二维数组地址是连续一条线的。

**所以可以看出在C++中二维数组在地址空间上是连续的**。

像Java是没有指针的，同时也不对程序员暴漏其元素的地址，寻址操作完全交给虚拟机。

所以看不到每个元素的地址情况，这里我以Java为例，也做一个实验。

```
public static void test_arr() {
    int[][] arr = {{1, 2, 3}, {3, 4, 5}, {6, 7, 8}, {9,9,9}};
    System.out.println(arr[0]);
    System.out.println(arr[1]);
    System.out.println(arr[2]);
    System.out.println(arr[3]);
}
```

输出的地址为：

```
[I@7852e922
[I@4e25154f
[I@70dea4e
[I@5c647e05
```

这里的数值也是16进制，这不是真正的地址，而是经过处理过后的数值了，我们也可以看出，二维数组的每一行头结点的地址是没有规则的，更谈不上连续。



============================================================

TODO 上述这段话，我想到时候看看，是否真的获取不到地址，结合虚拟机的原理？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？



**要知道数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能覆盖。**







## 面向对象





## 复用类，多态







## 接口



## 容器







list



红黑树



#### HashMap



最近拜读了一些Java Map的相关源码，不得不惊叹于JDK开发者们的鬼斧神工。他山之石可以攻玉，这些巧妙的设计思想非常有借鉴价值，可谓是最佳实践。然而，大多数有关Java Map原理的科普类文章都是专注于“点”，并没有连成“线”，甚至形成“网状结构”。因此，本文基于个人理解，对所阅读的部分源码进行了分类与总结，归纳出Map中的几个核心特性，包括：自动扩容、初始化与懒加载、哈希计算、位运算与并发，并结合源码进行深入讲解，希望看完本文的你也能从中获取到些许收获（本文默认采用JDK1.8中的HashMap）。

##### 一 自动扩容

> 最小可用原则，容量超过一定阈值便自动进行扩容。

扩容是通过resize方法来实现的。扩容发生在putVal方法的最后，即写入元素之后才会判断是否需要扩容操作，当自增后的size大于之前所计算好的阈值threshold，即执行resize操作。

![img](https://pic3.zhimg.com/80/v2-0ecb9f0efcc0031c6521f19668c6f2ce_1440w.jpg)

通过位运算<<1进行容量扩充，即扩容1倍，同时新的阈值newThr也扩容为老阈值的1倍。

![img](https://pic1.zhimg.com/80/v2-9b56cd67e115c8e2fc8e68df2934806c_1440w.jpg)

扩容时，总共存在三种情况：

- 哈希桶数组中某个位置只有1个元素，即不存在哈希冲突时，则直接将该元素copy至新哈希桶数组的对应位置即可。
- 哈希桶数组中某个位置的节点为树节点时，则执行红黑树的扩容操作。
- 哈希桶数组中某个位置的节点为普通节点时，则执行链表扩容操作，在JDK1.8中，为了避免之前版本中并发扩容所导致的死链问题，引入了高低位链表辅助进行扩容操作。

![img](https://pic3.zhimg.com/80/v2-76126ed0e062defec426cba291b6ffbe_1440w.jpg)

在日常的开发过程中，会遇到一些bad case，比如：

```text
HashMap hashMap = new HashMap(2);
hashMap.put("1", 1);
hashMap.put("2", 2);
hashMap.put("3", 3);
```

当hashMap设置最后一个元素3的时候，会发现当前的哈希桶数组大小已经达到扩容阈值2*0.75=1.5，紧接着会执行一次扩容操作，因此，此类的代码每次运行的时候都会进行一次扩容操作，效率低下。在日常开发过程中，一定要充分评估好HashMap的大小，尽可能保证扩容的阈值大于存储元素的数量，减少其扩容次数。

##### 二 初始化与懒加载

> 初始化的时候只会设置默认的负载因子，并不会进行其他初始化的操作，在首次使用的时候才会进行初始化。

当new一个新的HashMap的时候，不会立即对哈希数组进行初始化，而是在首次put元素的时候，通过resize()方法进行初始化。

![img](https://pic4.zhimg.com/80/v2-52dd5001cc4f80503f1b2c644bd55863_1440w.jpg)

resize()中会设置默认的初始化容量DEFAULT_INITIAL_CAPACITY为16，扩容的阈值为0.75*16 = 12，即哈希桶数组中元素达到12个便进行扩容操作。

最后创建容量为16的Node数组，并赋值给成员变量哈希桶table，即完成了HashMap的初始化操作。

![img](https://pic1.zhimg.com/80/v2-167705cc7c0f7dacede4345e5b38a838_1440w.jpg)

##### 三 哈希计算

哈希表以哈希命名，足以说明哈希计算在该数据结构中的重要程度。而在实现中，JDK并没有直接使用Object的native方法返回的hashCode作为最终的哈希值，而是进行了二次加工。

以下分别为HashMap与ConcurrentHashMap计算hash值的方法，核心的计算逻辑相同，都是使用key对应的hashCode与其hashCode右移16位的结果进行异或操作。此处，将高16位与低16位进行异或的操作称之为扰动函数，目的是将高位的特征融入到低位之中，降低哈希冲突的概率。

![img](https://pic1.zhimg.com/80/v2-5c92921fd92616aea633e644ec0241c0_1440w.jpg)

举个例子来理解下扰动函数的作用：

```text
hashCode(key1) = 0000 0000 0000 1111 0000 0000 0000 0010
hashCode(key2) = 0000 0000 0000 0000 0000 0000 0000 0010
```

若HashMap容量为4，在不使用扰动函数的情况下，key1与key2的hashCode注定会冲突（后两位相同，均为01）。

经过扰动函数处理后，可见key1与key2 hashcode的后两位不同，上述的哈希冲突也就避免了。

```text
hashCode(key1) ^ (hashCode(key1) >>> 16)
0000 0000 0000 1111 0000 0000 0000 1101

hashCode(key2) ^ (hashCode(key2) >>> 16)
0000 0000 0000 0000 0000 0000 0000 0010
```

这种增益会随着HashMap容量的减少而增加。《An introduction to optimising a hashing strategy》文章中随机选取了哈希值不同的352个字符串，当HashMap的容量为2^9时，使用扰动函数可以减少10%的碰撞，可见扰动函数的必要性。

此外，ConcurrentHashMap中经过扰乱函数处理之后，需要与HASH_BITS做与运算，HASH_BITS为0x7ffffff，即只有最高位为0，这样运算的结果使hashCode永远为正数。在ConcurrentHashMap中，预定义了几个特殊节点的hashCode，如：MOVED、TREEBIN、RESERVED，它们的hashCode均定义为负值。因此，将普通节点的hashCode限定为正数，也就是为了防止与这些特殊节点的hashCode产生冲突。

###### **1 哈希冲突**

通过哈希运算，可以将不同的输入值映射到指定的区间范围内，随之而来的是哈希冲突问题。考虑一个极端的case，假设所有的输入元素经过哈希运算之后，都映射到同一个哈希桶中，那么查询的复杂度将不再是O(1)，而是O(n)，相当于线性表的顺序遍历。因此，哈希冲突是影响哈希计算性能的重要因素之一。哈希冲突如何解决呢？主要从两个方面考虑，一方面是避免冲突，另一方面是在冲突时合理地解决冲突，尽可能提高查询效率。前者在上面的章节中已经进行介绍，即通过扰动函数来增加hashCode的随机性，避免冲突。针对后者，HashMap中给出了两种方案：拉链表与红黑树。

拉链表

在JDK1.8之前，HashMap中是采用拉链表的方法来解决冲突，即当计算出的hashCode对应的桶上已经存在元素，但两者key不同时，会基于桶中已存在的元素拉出一条链表，将新元素链到已存在元素的前面。当查询存在冲突的哈希桶时，会顺序遍历冲突链上的元素。同一key的判断逻辑如下图所示，先判断hash值是否相同，再比较key的地址或值是否相同。

![img](https://pic3.zhimg.com/80/v2-6b4e79d087597cf5309701070e48adfa_1440w.jpg)

（1）死链

在JDK1.8之前，HashMap在并发场景下扩容时存在一个bug，形成死链，导致get该位置元素的时候，会死循环，使CPU利用率高居不下。这也说明了HashMap不适于用在高并发的场景，高并发应该优先考虑JUC中的ConcurrentHashMap。然而，精益求精的JDK开发者们并没有选择绕过问题，而是选择直面问题并解决它。在JDK1.8之中，引入了高低位链表（双端链表）。

什么是高低位链表呢？在扩容时，哈希桶数组buckets会扩容一倍，以容量为8的HashMap为例，原有容量8扩容至16，将[0, 7]称为低位，[8, 15]称为高位，低位对应loHead、loTail，高位对应hiHead、hiTail。

扩容时会依次遍历旧buckets数组的每一个位置上面的元素：

- 若不存在冲突，则重新进行hash取模，并copy到新buckets数组中的对应位置。
- 若存在冲突元素，则采用高低位链表进行处理。通过e.hash & oldCap来判断取模后是落在高位还是低位。举个例子：假设当前元素hashCode为0001（忽略高位），其运算结果等于0，说明扩容后结果不变，取模后还是落在低位[0, 7]，即0001 & 1000 = 0000，还是原位置，再用低位链表将这类的元素链接起来。假设当前元素的hashCode为1001， 其运算结果不为0，即1001 & 1000 = 1000 ，扩容后会落在高位，新的位置刚好是旧数组索引（1） + 旧数据长度（8） = 9，再用高位链表将这些元素链接起来。最后，将高低位链表的头节点分别放在扩容后数组newTab的指定位置上，即完成了扩容操作。这种实现降低了对共享资源newTab的访问频次，先组织冲突节点，最后再放入newTab的指定位置。避免了JDK1.8之前每遍历一个元素就放入newTab中，从而导致并发扩容下的死链问题。

![img](https://pic1.zhimg.com/80/v2-3b9a5de58b2275fa0f4b090471a6b598_1440w.jpg)

红黑树

在JDK1.8之中，HashMap引入了红黑树来处理哈希冲突问题，而不再是拉链表。那么为什么要引入红黑树来替代链表呢？虽然链表的插入性能是O(1)，但查询性能却是O(n)，当哈希冲突元素非常多时，这种查询性能是难以接受的。因此，在JDK1.8中，如果冲突链上的元素数量大于8，并且哈希桶数组的长度大于64时，会使用红黑树代替链表来解决哈希冲突，此时的节点会被封装成TreeNode而不再是Node（TreeNode其实继承了Node，以利用多态特性），使查询具备O(logn)的性能。

这里简单地回顾一下红黑树，它是一种平衡的二叉树搜索树，类似地还有AVL树。两者核心的区别是AVL树追求“绝对平衡”，在插入、删除节点时，成本要高于红黑树，但也因此拥有了更好的查询性能，适用于读多写少的场景。然而，对于HashMap而言，读写操作其实难分伯仲，因此选择红黑树也算是在读写性能上的一种折中。

##### 四 位运算

###### **1 确定哈希桶数组大小**

> 找到大于等于给定值的最小2的整数次幂。

tableSizeFor根据输入容量大小cap来计算最终哈希桶数组的容量大小，找到大于等于给定值cap的最小2的整数次幂。乍眼一看，这一行一行的位运算让人云里雾里，莫不如采用类似找规律的方式来探索其中的奥秘。

![img](https://pic1.zhimg.com/80/v2-f2301f2430f3ae06db4e72ff4f018e74_1440w.jpg)

当cap为3时，计算过程如下：

```text
cap = 3
n = 2
n |= n >>> 1       010  | 001 = 011   n = 3
n |= n >>> 2       011  | 000 = 011   n = 3
n |= n >>> 4       011  | 000 = 011   n = 3
….
n = n + 1 = 4
```

当cap为5时，计算过程如下：

```text
cap = 5
n = 4
n |= n >>> 1    0100 | 0010 = 0110  n = 6
n |= n >>> 2    0110 | 0001 = 0111  n = 7
….
n = n + 1 = 8
```

因此，计算的意义在于找到大于等于cap的最小2的整数次幂。整个过程是找到cap对应二进制中最高位的1，然后每次以2倍的步长（依次移位1、2、4、8、16）复制最高位1到后面的所有低位，把最高位1后面的所有位全部置为1，最后进行+1，即完成了进位。

类似二进制位的变化过程如下：

```text
0100 1010
0111 1111
1000 0000
```

找到输入cap的最小2的整数次幂作为最终容量可以理解为最小可用原则，尽可能地少占用空间，但是为什么必须要2的整数次幂呢？答案是，为了提高计算与存储效率，使每个元素对应hash值能够准确落入哈希桶数组给定的范围区间内。确定数组下标采用的算法是 hash & (n - 1)，n即为哈希桶数组的大小。由于其总是2的整数次幂，这意味着n-1的二进制形式永远都是0000111111的形式，即从最低位开始，连续出现多个1，该二进制与任何值进行&运算都会使该值映射到指定区间[0, n-1]。比如：当n=8时，n-1对应的二进制为0111，任何与0111进行&运算都会落入[0,7]的范围内，即落入给定的8个哈希桶中，存储空间利用率100%。举个反例，当n=7，n-1对应的二进制为0110，任何与0110进行&运算会落入到第0、6、4、2个哈希桶，而不是[0,6]的区间范围内，少了1、3、5三个哈希桶，这导致存储空间利用率只有不到60%，同时也增加了哈希碰撞的几率。

###### **2 ASHIFT偏移量计算**

> 获取给定值的最高有效位数（移位除了能够进行乘除运算，还能用于保留高、低位操作，右移保留高位，左移保留低位）。

ConcurrentHashMap中的ABASE+ASHIFT是用来计算哈希数组中某个元素在实际内存中的初始位置，ASHIFT采取的计算方式是31与scale前导0的数量做差，也就是scale的实际位数-1。scale就是哈希桶数组Node[]中每个元素的大小，通过((long)i << ASHIFT) + ABASE)进行计算，便可得到数组中第i个元素的起始内存地址。

![img](https://pic4.zhimg.com/80/v2-2c72e1ccc0fd703d7bc67db2b70f27e7_1440w.jpg)

我们继续看下前导0的数量是怎么计算出来的，numberOfLeadingZeros是Integer的静态方法，还是沿用找规律的方式一探究竟。

![img](https://pic4.zhimg.com/80/v2-1b63144ec844fbae7c5de08abbdafb17_1440w.jpg)

假设 i = 0000 0000 0000 0100 0000 0000 0000 0000，n = 1

```text
i >>> 16  0000 0000 0000 0000 0000 0000 0000 0100   不为0

i >>> 24  0000 0000 0000 0000 0000 0000 0000 0000   等于0
```

右移了24位等于0，说明24位到31位之间肯定全为0，即n = 1 + 8 = 9，由于高8位全为0，并且已经将信息记录至n中，因此可以舍弃高8位，即 i <<= 8。此时，

```text
i = 0000 0100 0000 0000 0000 0000 0000 0000
```

类似地，i >>> 28 也等于0，说明28位到31位全为0，n = 9 + 4 = 13，舍弃高4位。此时，

```text
i = 0100 0000 0000 0000 0000 0000 0000 0000
```

继续运算，

```text
i >>> 30  0000 0000 0000 0000 0000 0000 0000 0001   不为0
i >>> 31  0000 0000 0000 0000 0000 0000 0000 0000   等于0
```

最终可得出n = 13，即有13个前导0。n -= i >>> 31是检查最高位31位是否是1，因为n初始化为1，如果最高位是1，则不存在前置0，即n = n - 1 = 0。

总结一下，以上的操作其实是基于二分法的思想来定位二进制中1的最高位，先看高16位，若为0，说明1存在于低16位；反之存在高16位。由此将搜索范围由32位（确切的说是31位）减少至16位，进而再一分为二，校验高8位与低8位，以此类推。

计算过程中校验的位数依次为16、8、4、2、1，加起来刚好为31。为什么是31不是32呢？因为前置0的数量为32的情况下i只能为0，在前面的if条件中已经进行过滤。这样一来，非0值的情况下，前置0只能出现在高31位，因此只需要校验高31位即可。最终，用总位数减去计算出来的前导0的数量，即可得出二进制的最高有效位数。代码中使用的是31 -
Integer.numberOfLeadingZeros(scale)，而不是总位数32，这是为了能够得到哈希桶数组中第i个元素的起始内存地址，方便进行CAS等操作。

##### 五 并发

###### **1 悲观锁**

全表锁

HashTable中采用了全表锁，即所有操作均上锁，串行执行，如下图中的put方法所示，采用synchronized关键字修饰。这样虽然保证了线程安全，但是在多核处理器时代也极大地影响了计算性能，这也致使HashTable逐渐淡出开发者们的视野。

![img](https://pic2.zhimg.com/80/v2-efa99dc993ce0996b251a504e7d5bd35_1440w.jpg)

分段锁

针对HashTable中锁粒度过粗的问题，在JDK1.8之前，ConcurrentHashMap引入了分段锁机制。整体的存储结构如下图所示，在原有结构的基础上拆分出多个segment，每个segment下再挂载原来的entry（上文中经常提到的哈希桶数组），每次操作只需要锁定元素所在的segment，不需要锁定整个表。因此，锁定的范围更小，并发度也会得到提升。

![img](https://pic1.zhimg.com/80/v2-ca34f88b24acf2a89af7341790d2ecc0_1440w.jpg)

###### **2 乐观锁**

Synchronized+CAS

虽然引入了分段锁的机制，即可以保证线程安全，又可以解决锁粒度过粗导致的性能低下问题，但是对于追求极致性能的工程师来说，这还不是性能的天花板。因此，在JDK1.8中，ConcurrentHashMap摒弃了分段锁，使用了乐观锁的实现方式。放弃分段锁的原因主要有以下几点：

- 使用segment之后，会增加ConcurrentHashMap的存储空间。
- 当单个segment过大时，并发性能会急剧下降。

ConcurrentHashMap在JDK1.8中的实现废弃了之前的segment结构，沿用了与HashMap中的类似的Node数组结构。

![img](https://pic4.zhimg.com/80/v2-13cb919604808ab8ddebf3f0f6449123_1440w.jpg)

ConcurrentHashMap中的乐观锁是采用synchronized+CAS进行实现的。这里主要看下put的相关代码。

当put的元素在哈希桶数组中不存在时，则直接CAS进行写操作。

![img](https://pic2.zhimg.com/80/v2-3d06f86c261b997aa3eb0f0f33162df1_1440w.jpg)

这里涉及到了两个重要的操作，tabAt与casTabAt。可以看出，这里面都使用了Unsafe类的方法。Unsafe这个类在日常的开发过程中比较罕见。我们通常对Java语言的认知是：Java语言是安全的，所有操作都基于JVM，在安全可控的范围内进行。然而，Unsafe这个类会打破这个边界，使Java拥有C的能力，可以操作任意内存地址，是一把双刃剑。这里使用到了前文中所提到的ASHIFT，来计算出指定元素的起始内存地址，再通过getObjectVolatile与compareAndSwapObject分别进行取值与CAS操作。

在获取哈希桶数组中指定位置的元素时为什么不能直接get而是要使用getObjectVolatile呢？因为在JVM的内存模型中，每个线程有自己的工作内存，也就是栈中的局部变量表，它是主存的一份copy。因此，线程1对某个共享资源进行了更新操作，并写入到主存，而线程2的工作内存之中可能还是旧值，脏数据便产生了。Java中的volatile是用来解决上述问题，保证可见性，任意线程对volatile关键字修饰的变量进行更新时，会使其它线程中该变量的副本失效，需要从主存中获取最新值。虽然ConcurrentHashMap中的Node数组是由volatile修饰的，可以保证可见性，但是Node数组中元素是不具备可见性的。因此，在获取数据时通过Unsafe的方法直接到主存中拿，保证获取的数据是最新的。

![img](https://pic1.zhimg.com/80/v2-2a0ec6f2403fbf7235bb39d0bb24ae70_1440w.jpg)

继续往下看put方法的逻辑，当put的元素在哈希桶数组中存在，并且不处于扩容状态时，则使用synchronized锁定哈希桶数组中第i个位置中的第一个元素f（头节点2），接着进行double check，类似于DCL单例模式的思想。校验通过后，会遍历当前冲突链上的元素，并选择合适的位置进行put操作。此外，ConcurrentHashMap也沿用了HashMap中解决哈希冲突的方案，链表+红黑树。这里只有在发生哈希冲突的情况下才使用synchronized锁定头节点，其实是比分段锁更细粒度的锁实现，只在特定场景下锁定其中一个哈希桶，降低锁的影响范围。

![img](https://pic1.zhimg.com/80/v2-9a575ca767b29e41f94fa6665ac89b9c_1440w.jpg)

Java Map针对并发场景解决方案的演进方向可以归结为，从悲观锁到乐观锁，从粗粒度锁到细粒度锁，这也可以作为我们在日常并发编程中的指导方针。

###### **3 并发求和**

CounterCell是JDK1.8中引入用来并发求和的利器，而在这之前采用的是【尝试无锁求和】+【冲突时加锁重试】的策略。看下CounterCell的注释，它是改编自LongAdder和Striped64。我们先看下求和操作，其实就是取baseCount作为初始值，然后遍历CounterCell数组中的每一个cell，将各个cell的值进行累加。这里额外说明下@sun.misc.Contender注解的作用，它是Java8中引入用来解决缓存行伪共享问题的。什么是伪共享呢？简单说下，考虑到CPU与主存之间速度的巨大差异，在CPU中引入了L1、L2、L3多级缓存，缓存中的存储单位是缓存行，缓存行大小为2的整数次幂字节，32-256个字节不等，最常见的是64字节。因此，这将导致不足64字节的变量会共享同一个缓存行，其中一个变量失效会影响到同一个缓存行中的其他变量，致使性能下降，这就是伪共享问题。考虑到不同CPU的缓存行单位的差异性，Java8中便通过该注解将这种差异性屏蔽，根据实际缓存行大小来进行填充，使被修饰的变量能够独占一个缓存行。

![img](https://pic1.zhimg.com/80/v2-54641c589fa421ad31337f0508dbb9a0_1440w.jpg)

![img](https://pic2.zhimg.com/80/v2-b0653f6fa4cbfef65e7e118acf2ed6fd_1440w.jpg)

再来看下CounterCell是如何实现计数的，每当map中的容量有变化时会调用addCount进行计数，核心逻辑如下：

- 当counterCells不为空，或counterCells为空且对baseCount进行CAS操作失败时进入到后续计数处理逻辑，否则对baseCount进行CAS操作成功，直接返回。
- 后续计数处理逻辑中会调用核心计数方法fullAddCount，但需要满足以下4个条件中的任意一个：1、counterCells为空；2、counterCells的size为0；3、counterCells对应位置上的counterCell为空；4、CAS更新counterCells对应位置上的counterCell失败。这些条件背后的语义是，当前情况下，计数已经或曾经出现过并发冲突，需要优先借助于CounterCell来解决。若counterCells与对应位置上的元素已经初始化（条件4），则先尝试CAS进行更新，若失败则调用fullAddCount继续处理。若counterCells与对应位置上的元素未初始化完成（条件1、2、3），也要调用AddCount进行后续处理。
- 这里确定cell下标时采用了ThreadLocalRandom.getProbe()作为哈希值，这个方法返回的是当前Thread中threadLocalRandomProbe字段的值。而且当哈希值冲突时，还可以通过advanceProbe方法来更换哈希值。这与HashMap中的哈希值计算逻辑不同，因为HashMap中要保证同一个key进行多次哈希计算的哈希值相同并且能定位到对应的value，即便两个key的哈希值冲突也不能随便更换哈希值，只能采用链表或红黑树处理冲突。然而在计数场景，我们并不需要维护key-value的关系，只需要在counterCells中找到一个合适的位置放入计数cell，位置的差异对最终的求和结果是没有影响的，因此当冲突时可以基于随机策略更换一个哈希值来避免冲突。

![img](https://pic3.zhimg.com/80/v2-9f37662ab4a160c5058d778adeaefab2_1440w.jpg)

接着，我们来看下核心计算逻辑fullAddCount，代码还是比较多的，核心流程是通过一个死循环来实现的，循环体中包含了3个处理分支，为了方便讲解我将它们依次定义A、B、C。

- A：表示counterCells已经初始化完成，因此可以尝试更新或创建对应位置的CounterCell。
- B：表示counterCells未初始化完成，且无冲突（拿到cellsBusy锁），则加锁初始化counterCells，初始容量为2。
- C：表示counterCells未初始化完成，且有冲突（未能拿到cellsBusy锁），则CAS更新baseCount，baseCount在求和时也会被算入到最终结果中，这也相当于是一种兜底策略，既然counterCells正在被其他线程锁定，那当前线程也没必要再等待了，直接尝试使用baseCount进行累加。

其中，A分支中涉及到的操作又可以拆分为以下几点：

- a1：对应位置的CounterCell未创建，采用锁+Double Check的策略尝试创建CounterCell，失败的话则continue进行重试。这里面采用的锁是cellsBusy，它保证创建CounterCell并放入counterCells时一定是串行执行，避免重复创建，其实就是使用了DCL单例模式的策略。在CounterCells的创建、扩容中都需要使用该锁。
- a2：冲突检测，变量wasUncontended是调用方addCount中传入的，表示前置的CAS更新cell失败，有冲突，需要更换哈希值【a7】后继续重试。
- a3：对应位置的CounterCell不为空，直接CAS进行更新。
- a4：冲突检测，当counterCells的引用值不等于当前线程对应的引用值时，说明有其他线程更改了counterCells的引用，出现冲突，则将collide设为false，下次迭代时可进行扩容。容量限制，counterCells容量的最大值为大于等于NCPU（实际机器CPU核心的数量）的最小2的整数次幂，当达到容量限制时后面的扩容分支便永远不会执行。这里限制的意义在于，真实并发度是由CPU核心来决定，当counterCells容量与CPU核心数量相等时，理想情况下就算所有CPU核心在同时运行不同的计数线程时，都不应该出现冲突，每个线程选择各自的cell进行处理即可。如果出现冲突，一定是哈希值的问题，因此采取的措施是重新计算哈希值a7，而不是通过扩容来解决。时间换空间，避免不必要的存储空间浪费，非常赞的想法~
- a5：更新扩容标志位，下次迭代时将会进行扩容。
- a6：进行加锁扩容，每次扩容1倍。
- a7：更换哈希值。

```text
private final void fullAddCount(long x, boolean wasUncontended) {
        int h;
        // 初始化probe
        if ((h = ThreadLocalRandom.getProbe()) == 0) {
            ThreadLocalRandom.localInit();      // force initialization
            h = ThreadLocalRandom.getProbe();
            wasUncontended = true;
        }
        // 用来控制扩容操作
        boolean collide = false;                // True if last slot nonempty
        for (;;) {
            CounterCell[] as; CounterCell a; int n; long v;
            // 【A】counterCells已经初始化完毕
            if ((as = counterCells) != null && (n = as.length) > 0) {
                // 【a1】对应位置的CounterCell未创建
                if ((a = as[(n - 1) & h]) == null) {
                    // cellsBusy其实是一个锁，cellsBusy=0时表示无冲突
                    if (cellsBusy == 0) {            // Try to attach new Cell
                        // 创建新的CounterCell
                        CounterCell r = new CounterCell(x); // Optimistic create
                        // Double Check，加锁（通过CAS将cellsBusy设置1）
                        if (cellsBusy == 0 &&
                            U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                            boolean created = false;
                            try {               // Recheck under lock
                                CounterCell[] rs; int m, j;
                                // Double Check
                                if ((rs = counterCells) != null &&
                                    (m = rs.length) > 0 &&
                                    rs[j = (m - 1) & h] == null) {
                                    // 将新创建的CounterCell放入counterCells中
                                    rs[j] = r;
                                    created = true;
                                }
                            } finally {
                                // 解锁，这里为什么不用CAS？因为当前流程中需要在获取锁的前提下进行，即串行执行，因此不存在并发更新问题，只需要正常更新即可
                                cellsBusy = 0;
                            }
                            if (created)
                                break;
                            // 创建失败则重试
                            continue;           // Slot is now non-empty
                        }
                    }
                    // cellsBusy不为0，说明被其他线程争抢到了锁，还不能考虑扩容
                    collide = false;
                }
                //【a2】冲突检测
                else if (!wasUncontended)       // CAS already known to fail
                    // 调用方addCount中CAS更新cell失败，有冲突，则继续尝试CAS
                    wasUncontended = true;      // Continue after rehash

                //【a3】对应位置的CounterCell不为空，直接CAS进行更新
                else if (U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))
                    break;
                //【a4】容量限制
                else if (counterCells != as || n >= NCPU)
                    // 说明counterCells容量的最大值为大于NCPU（实际机器CPU核心的数量）最小2的整数次幂。
                    // 这里限制的意义在于，并发度是由CPU核心来决定，当counterCells容量与CPU核心数量相等时，理论上讲就算所有CPU核心都在同时运行不同的计数线程时，都不应该出现冲突，每个线程选择各自的cell进行处理即可。如果出现冲突，一定是哈希值的问题，因此采取的措施是重新计算哈希值（h = ThreadLocalRandom.advanceProbe(h)），而不是通过扩容来解决

                    // 当n大于NCPU时后面的分支就不会走到了
                    collide = false;            // At max size or stale
                // 【a5】更新扩容标志位
                else if (!collide)
                    // 说明映射到cell位置不为空，并且尝试进行CAS更新时失败了，则说明有竞争，将collide设置为true，下次迭代时执行后面的扩容操作，降低竞争度
                    // 有竞争时，执行rehash+扩容，当容量大于CPU核心时则停止扩容只进行rehash
                    collide = true;
                // 【a6】加锁扩容
                else if (cellsBusy == 0 &&
                         U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                    // 加锁扩容
                    try {
                        if (counterCells == as) {// Expand table unless stale
                            // 扩容1倍
                            CounterCell[] rs = new CounterCell[n << 1];
                            for (int i = 0; i < n; ++i)
                                rs[i] = as[i];
                            counterCells = rs;
                        }
                    } finally {
                        cellsBusy = 0;
                    }
                    collide = false;
                    continue;                   // Retry with expanded table
                }
                //【a7】更换哈希值
                h = ThreadLocalRandom.advanceProbe(h);
            }
            // 【B】counterCells未初始化完成，且无冲突，则加锁初始化counterCells
            else if (cellsBusy == 0 && counterCells == as &&
                     U.compareAndSwapInt(this, CELLSBUSY, 0, 1)) {
                boolean init = false;
                try {                           // Initialize table
                    if (counterCells == as) {
                        CounterCell[] rs = new CounterCell[2];
                        rs[h & 1] = new CounterCell(x);
                        counterCells = rs;
                        init = true;
                    }
                } finally {
                    cellsBusy = 0;
                }
                if (init)
                    break;
            }
            // 【C】counterCells未初始化完成，且有冲突，则CAS更新baseCount
            else if (U.compareAndSwapLong(this, BASECOUNT, v = baseCount, v + x))
                break;                          // Fall back on using base
        }
```

CounterCell的设计很巧妙，它的背后其实就是JDK1.8中的LongAdder。核心思想是：在并发较低的场景下直接采用baseCount累加，否则结合counterCells，将不同的线程散列到不同的cell中进行计算，尽可能地确保访问资源的隔离，减少冲突。LongAdder相比较于AtomicLong中无脑CAS的策略，在高并发的场景下，能够减少CAS重试的次数，提高计算效率。

























## 异常













如果异常出现的话,会立刻终止程序,所以我们得处理异常:
1. 该方法不处理,而是声明抛出,由该方法的调用者来处理(throws)。

2. 在方法中使用try-catch的语句块来处理异常。
    try-catch的方式就是捕获异常。
    捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。
    捕获异常语法如下：

  ```
  
  ```

  try：该代码块中编写可能产生异常的代码。
  catch：用来进行某种异常的捕获，实现对捕获到的异常进行处理。
  注意:try和catch都不能单独使用,必须连用。





Throwable类中定义了一些查看方法:
public String getMessage() :获取异常的描述信息,原因(提示给用户的时候,就提示错误原因。
public String toString() :获取异常的类型和异常描述信息(不用)。
public void printStackTrace() :打印异常的跟踪栈信息并输出到控制台。





finally：有一些特定的代码无论异常是否发生，都需要执行。另外，因为异常会引发程序跳转，导致有些语句执行
不到。而finally就是解决这个问题的，在finally代码块中存放的代码都是一定会被执行的。
什么时候的代码必须最终执行？
当我们在try语句块中打开了一些物理资源(磁盘文件/网络连接/数据库连接等),我们都得在使用完之后,最终关闭打开
的资源。
finally的语法:
try...catch....finally:自身需要处理异常,最终还得关闭资源。
注意:finally不能单独使用。
比如在我们之后学习的IO流中，当打开了一个关联文件的资源，最后程序不管结果如何，都需要把这个资源关闭
掉。



当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。



？？？？？？？？？？？？？？？？？

Objects非空判断
还记得我们学习过一个类Objects吗，曾经提到过它由一些静态的实用方法组成，这些方法是null-save（空指针安
全的）或null-tolerant（容忍空指针的），那么在它的源码中，对对象为null的值进行了抛出异常操作。

查看源码发现这里对为null的进行了抛出异常操作：

public static <T> T requireNonNull(T obj) {
if (obj == null)
throw new NullPointerException()  ;
return obj;
}

```java
public static <T> T requireNonNull(T obj) 
//  查看指定引用对象不是null
```

查看源码发现这里对为null的进行了抛出异常操作：

```java
public static <T> T requireNonNull(T obj) {
if (obj == null)
throw new NullPointerException()  ;
return obj;
}
```

？？？？？？？？？？？？？？？？？？？？？？



多个异常使用捕获又该如何处理呢？
1. 多个异常分别处理。
2. 多个异常一次捕获，多次处理。
3. 多个异常一次捕获一次处理。
一般我们是使用一次捕获多次处理方式，格式如下：





```java
try{
编写可能会出现异常的代码
}catch(异常类型A e){ 当try中出现A类型异常,就用该catch来捕获.
处理异常的代码
//记录日志/打印异常信息/继续抛出异常
}catch(异常类型B e){ 当try中出现B类型异常,就用该catch来捕获.
处理异常的代码
//记录日志/打印异常信息/继续抛出异常
}
```



注意:这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异
常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。

1. 运行时异常被抛出可以不处理。即不捕获也不声明抛出。
2. 如果finally有return语句,永远返回finally中的结果,避免该情况.
3. 如果父类抛出了多个异常,子类重写父类方法时,抛出和父类相同的异常或者是父类异常的子类或者不抛出异
    常。
4. 父类方法没有抛出异常，子类重写父类该方法时也不可抛出异常。此时子类产生该异常，只能捕获处理，不
    能声明抛出





## 泛型



## 反射







？？？？？？？？？？？？？？？

此文直接摘抄，需要整理



#### 定义

**[JAVA反射机制](https://baike.baidu.com/item/JAVA反射机制/6015990)是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。**

#### 用途

在日常的第三方应用开发过程中，经常会遇到某个类的某个成员变量、方法或是属性是私有的或是只对系统应用开放，这时候就可以利用Java的反射机制通过反射来获取所需的私有成员或是方法。当然，也不是所有的都适合反射，之前就遇到一个案例，通过反射得到的结果与预期不符。阅读源码发现，经过层层调用后在最终返回结果的地方对应用的权限进行了校验，对于没有权限的应用返回值是没有意义的缺省值，否则返回实际值起到保护用户的隐私目的。

#### 反射机制的相关类

与Java反射相关的类如下：

| 类名          | 用途                                             |
| ------------- | ------------------------------------------------ |
| Class类       | 代表类的实体，在运行的Java应用程序中表示类和接口 |
| Field类       | 代表类的成员变量（成员变量也称为类的属性）       |
| Method类      | 代表类的方法                                     |
| Constructor类 | 代表类的构造方法                                 |

#### Class类

[Class](https://developer.android.google.cn/reference/java/lang/Class)代表类的实体，在运行的Java应用程序中表示类和接口。在这个类中提供了很多有用的方法，这里对他们简单的分类介绍。

- **获得类相关的方法**

| 方法                       | 用途                                                   |
| -------------------------- | ------------------------------------------------------ |
| asSubclass(Class<U> clazz) | 把传递的类的对象转换成代表其子类的对象                 |
| Cast                       | 把对象转换成代表类或是接口的对象                       |
| getClassLoader()           | 获得类的加载器                                         |
| getClasses()               | 返回一个数组，数组中包含该类中所有公共类和接口类的对象 |
| getDeclaredClasses()       | 返回一个数组，数组中包含该类中所有类和接口类的对象     |
| forName(String className)  | 根据类名返回类的对象                                   |
| getName()                  | 获得类的完整路径名字                                   |
| newInstance()              | 创建类的实例                                           |
| getPackage()               | 获得类的包                                             |
| getSimpleName()            | 获得类的名字                                           |
| getSuperclass()            | 获得当前类继承的父类的名字                             |
| getInterfaces()            | 获得当前类实现的类或是接口                             |

- **获得类中属性相关的方法**

| 方法                          | 用途                   |
| ----------------------------- | ---------------------- |
| getField(String name)         | 获得某个公有的属性对象 |
| getFields()                   | 获得所有公有的属性对象 |
| getDeclaredField(String name) | 获得某个属性对象       |
| getDeclaredFields()           | 获得所有属性对象       |

- **获得类中注解相关的方法**

| 方法                                            | 用途                                   |
| ----------------------------------------------- | -------------------------------------- |
| getAnnotation(Class<A> annotationClass)         | 返回该类中与参数类型匹配的公有注解对象 |
| getAnnotations()                                | 返回该类所有的公有注解对象             |
| getDeclaredAnnotation(Class<A> annotationClass) | 返回该类中与参数类型匹配的所有注解对象 |
| getDeclaredAnnotations()                        | 返回该类所有的注解对象                 |

- **获得类中构造器相关的方法**

| 方法                                               | 用途                                   |
| -------------------------------------------------- | -------------------------------------- |
| getConstructor(Class...<?> parameterTypes)         | 获得该类中与参数类型匹配的公有构造方法 |
| getConstructors()                                  | 获得该类的所有公有构造方法             |
| getDeclaredConstructor(Class...<?> parameterTypes) | 获得该类中与参数类型匹配的构造方法     |
| getDeclaredConstructors()                          | 获得该类所有构造方法                   |

- **获得类中方法相关的方法**

| 方法                                                       | 用途                   |
| ---------------------------------------------------------- | ---------------------- |
| getMethod(String name, Class...<?> parameterTypes)         | 获得该类某个公有的方法 |
| getMethods()                                               | 获得该类所有公有的方法 |
| getDeclaredMethod(String name, Class...<?> parameterTypes) | 获得该类某个方法       |
| getDeclaredMethods()                                       | 获得该类所有方法       |

- **类中其他重要的方法**

| 方法                                                         | 用途                             |
| ------------------------------------------------------------ | -------------------------------- |
| isAnnotation()                                               | 如果是注解类型则返回true         |
| isAnnotationPresent(Class<? extends Annotation> annotationClass) | 如果是指定类型注解类型则返回true |
| isAnonymousClass()                                           | 如果是匿名类则返回true           |
| isArray()                                                    | 如果是一个数组类则返回true       |
| isEnum()                                                     | 如果是枚举类则返回true           |
| isInstance(Object obj)                                       | 如果obj是该类的实例则返回true    |
| isInterface()                                                | 如果是接口类则返回true           |
| isLocalClass()                                               | 如果是局部类则返回true           |
| isMemberClass()                                              | 如果是内部类则返回true           |

# Field类

[Field](https://developer.android.google.cn/reference/java/lang/reflect/Field)代表类的成员变量（成员变量也称为类的属性）。

| 方法                          | 用途                    |
| ----------------------------- | ----------------------- |
| equals(Object obj)            | 属性与obj相等则返回true |
| get(Object obj)               | 获得obj中对应的属性值   |
| set(Object obj, Object value) | 设置obj中对应属性值     |

# Method类

[Method](https://developer.android.google.cn/reference/java/lang/reflect/Method)代表类的方法。

| 方法                               | 用途                                     |
| ---------------------------------- | ---------------------------------------- |
| invoke(Object obj, Object... args) | 传递object对象及参数调用该对象对应的方法 |

# Constructor类

[Constructor](https://developer.android.google.cn/reference/java/lang/reflect/Constructor)代表类的构造方法。

| 方法                            | 用途                       |
| ------------------------------- | -------------------------- |
| newInstance(Object... initargs) | 根据传递的参数创建类的对象 |

# 示例

为了演示反射的使用，首先构造一个与书籍相关的model——Book.java，然后通过反射方法示例创建对象、反射私有构造方法、反射私有属性、反射私有方法，最后给出两个比较复杂的反射示例——获得当前ZenMode和关机Shutdown。

- **被反射类Book.java**



```tsx
public class Book{
    private final static String TAG = "BookTag";

    private String name;
    private String author;

    @Override
    public String toString() {
        return "Book{" +
                "name='" + name + '\'' +
                ", author='" + author + '\'' +
                '}';
    }

    public Book() {
    }

    private Book(String name, String author) {
        this.name = name;
        this.author = author;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getAuthor() {
        return author;
    }

    public void setAuthor(String author) {
        this.author = author;
    }

    private String declaredMethod(int index) {
        String string = null;
        switch (index) {
            case 0:
                string = "I am declaredMethod 1 !";
                break;
            case 1:
                string = "I am declaredMethod 2 !";
                break;
            default:
                string = "I am declaredMethod 1 !";
        }

        return string;
    }
}
```

- **反射逻辑封装在ReflectClass.java**



```java
public class ReflectClass {
    private final static String TAG = "peter.log.ReflectClass";

    // 创建对象
    public static void reflectNewInstance() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Object objectBook = classBook.newInstance();
            Book book = (Book) objectBook;
            book.setName("Android进阶之光");
            book.setAuthor("刘望舒");
            Log.d(TAG,"reflectNewInstance book = " + book.toString());
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 反射私有的构造方法
    public static void reflectPrivateConstructor() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Constructor<?> declaredConstructorBook = classBook.getDeclaredConstructor(String.class,String.class);
            declaredConstructorBook.setAccessible(true);
            Object objectBook = declaredConstructorBook.newInstance("Android开发艺术探索","任玉刚");
            Book book = (Book) objectBook;
            Log.d(TAG,"reflectPrivateConstructor book = " + book.toString());
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 反射私有属性
    public static void reflectPrivateField() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Object objectBook = classBook.newInstance();
            Field fieldTag = classBook.getDeclaredField("TAG");
            fieldTag.setAccessible(true);
            String tag = (String) fieldTag.get(objectBook);
            Log.d(TAG,"reflectPrivateField tag = " + tag);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 反射私有方法
    public static void reflectPrivateMethod() {
        try {
            Class<?> classBook = Class.forName("com.android.peter.reflectdemo.Book");
            Method methodBook = classBook.getDeclaredMethod("declaredMethod",int.class);
            methodBook.setAccessible(true);
            Object objectBook = classBook.newInstance();
            String string = (String) methodBook.invoke(objectBook,0);

            Log.d(TAG,"reflectPrivateMethod string = " + string);
        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    // 获得系统Zenmode值
    public static int getZenMode() {
        int zenMode = -1;
        try {
            Class<?> cServiceManager = Class.forName("android.os.ServiceManager");
            Method mGetService = cServiceManager.getMethod("getService", String.class);
            Object oNotificationManagerService = mGetService.invoke(null, Context.NOTIFICATION_SERVICE);
            Class<?> cINotificationManagerStub = Class.forName("android.app.INotificationManager$Stub");
            Method mAsInterface = cINotificationManagerStub.getMethod("asInterface",IBinder.class);
            Object oINotificationManager = mAsInterface.invoke(null,oNotificationManagerService);
            Method mGetZenMode = cINotificationManagerStub.getMethod("getZenMode");
            zenMode = (int) mGetZenMode.invoke(oINotificationManager);
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        return zenMode;
    }

    // 关闭手机
    public static void shutDown() {
        try {
            Class<?> cServiceManager = Class.forName("android.os.ServiceManager");
            Method mGetService = cServiceManager.getMethod("getService",String.class);
            Object oPowerManagerService = mGetService.invoke(null,Context.POWER_SERVICE);
            Class<?> cIPowerManagerStub = Class.forName("android.os.IPowerManager$Stub");
            Method mShutdown = cIPowerManagerStub.getMethod("shutdown",boolean.class,String.class,boolean.class);
            Method mAsInterface = cIPowerManagerStub.getMethod("asInterface",IBinder.class);
            Object oIPowerManager = mAsInterface.invoke(null,oPowerManagerService);
            mShutdown.invoke(oIPowerManager,true,null,true);

        } catch (Exception ex) {
            ex.printStackTrace();
        }
    }

    public static void shutdownOrReboot(final boolean shutdown, final boolean confirm) {
        try {
            Class<?> ServiceManager = Class.forName("android.os.ServiceManager");
            // 获得ServiceManager的getService方法
            Method getService = ServiceManager.getMethod("getService", java.lang.String.class);
            // 调用getService获取RemoteService
            Object oRemoteService = getService.invoke(null, Context.POWER_SERVICE);
            // 获得IPowerManager.Stub类
            Class<?> cStub = Class.forName("android.os.IPowerManager$Stub");
            // 获得asInterface方法
            Method asInterface = cStub.getMethod("asInterface", android.os.IBinder.class);
            // 调用asInterface方法获取IPowerManager对象
            Object oIPowerManager = asInterface.invoke(null, oRemoteService);
            if (shutdown) {
                // 获得shutdown()方法
                Method shutdownMethod = oIPowerManager.getClass().getMethod(
                        "shutdown", boolean.class, String.class, boolean.class);
                // 调用shutdown()方法
                shutdownMethod.invoke(oIPowerManager, confirm, null, false);
            } else {
                // 获得reboot()方法
                Method rebootMethod = oIPowerManager.getClass().getMethod("reboot",
                        boolean.class, String.class, boolean.class);
                // 调用reboot()方法
                rebootMethod.invoke(oIPowerManager, confirm, null, false);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

- **调用相应反射逻辑方法**



```php
        try {
            // 创建对象
            ReflectClass.reflectNewInstance();

            // 反射私有的构造方法
            ReflectClass.reflectPrivateConstructor();

            // 反射私有属性
            ReflectClass.reflectPrivateField();

            // 反射私有方法
            ReflectClass.reflectPrivateMethod();
        } catch (Exception ex) {
            ex.printStackTrace();
        }

        Log.d(TAG," zenmode = " + ReflectClass.getZenMode());
```

Log输出结果如下：



```csharp
08-27 15:11:37.999 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectNewInstance book = Book{name='Android进阶之光', author='刘望舒'}
08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateConstructor book = Book{name='Android开发艺术探索', author='任玉刚'}
08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateField tag = BookTag
08-27 15:11:38.000 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectClass: reflectPrivateMethod string = I am declaredMethod 1 !
08-27 15:11:38.004 11987-11987/com.android.peter.reflectdemo D/peter.log.ReflectDemo:  zenmode = 0
```

# 总结

本文列举了反射机制使用过程中常用的、重要的一些类及其方法，更多信息和用法需要近一步的阅读Google提供的相关文档和示例。

在阅读Class类文档时发现一个特点，以通过反射获得Method对象为例，一般会提供四种方法，getMethod(parameterTypes)、getMethods()、getDeclaredMethod(parameterTypes)和getDeclaredMethods()。getMethod(parameterTypes)用来获取某个公有的方法的对象，getMethods()获得该类所有公有的方法，getDeclaredMethod(parameterTypes)获得该类某个方法，getDeclaredMethods()获得该类所有方法。**带有Declared修饰的方法可以反射到私有的方法，没有Declared修饰的只能用来反射公有的方法。**其他的Annotation、Field、Constructor也是如此。

在ReflectClass类中还提供了两种反射PowerManager.shutdown()的方法，在调用的时候会输出如下log，提示没有相关权限。之前在项目中尝试反射其他方法的时候还遇到过有权限和没权限返回的值不一样的情况。**如果源码中明确进行了权限验证，而你的应用又无法获得这个权限的话，建议就不要浪费时间反射了。**



```bash
 W/System.err: java.lang.reflect.InvocationTargetException
 W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
 W/System.err:     at .ReflectClass.shutDown(ReflectClass.java:104)
 W/System.err:     at .MainActivity$1.onClick(MainActivity.java:25)
 W/System.err:     at android.view.View.performClick(View.java:6259)
 W/System.err:     at android.view.View$PerformClick.run(View.java:24732)
 W/System.err:     at android.os.Handler.handleCallback(Handler.java:789)
 W/System.err:     at android.os.Handler.dispatchMessage(Handler.java:98)
 W/System.err:     at android.os.Looper.loop(Looper.java:164)
 W/System.err:     at android.app.ActivityThread.main(ActivityThread.java:6592)
 W/System.err:     at java.lang.reflect.Method.invoke(Native Method)
 W/System.err:     at com.android.internal.os.Zygote$MethodAndArgsCaller.run(Zygote.java:240)
 W/System.err:     at com.android.internal.os.ZygoteInit.main(ZygoteInit.java:769)
 W/System.err: Caused by: java.lang.SecurityException: Neither user 10224 nor current process has android.permission.REBOOT.
 W/System.err:     at android.os.Parcel.readException(Parcel.java:1942)
 W/System.err:     at android.os.Parcel.readException(Parcel.java:1888)
 W/System.err:     at android.os.IPowerManager$Stub$Proxy.shutdown(IPowerManager.java:787)
 W/System.err:  ... 12 more
```

以上直接摘抄，未作整理

？？？？？？？？？？？？





获取Class类的对象：forName()、类名.Class、对象.getClass()
源代码阶段[forName()]-->Class对象阶段(内存)[类名.Class]-->Runtime阶段[对象.getClass()]
.java文件--编译-->Class文件--类加载器-->Class对象--创建对象-->new JavaBean()

















什么是反射，反射原理
Java反射的原理:java类的执行需要经历以下过程，

编译:.java文件编译后生成.class字节码文件
加载：类加载器负责根据一个类的全限定名来读取此类的二进制字节流到JVM内部，并存储在运行时内存区的方法区，然后将其转换为一个与目标类型对应的java.lang.Class对象实例
连接：细分三步
  验证：格式（class文件规范） 语义（final类是否有子类） 操作
  准备：静态变量赋初值和内存空间，final修饰的内存空间直接赋原值，此处不是用户指定的初值。
  解析：符号引用转化为直接引用，分配地址
初始化:有父类先初始化父类，然后初始化自己；将static修饰代码执行一遍，如果是静态变量，则用用户指定值覆盖原有初值；如果是代码块，则执行一遍操作。

Java的反射就是利用上面第二步加载到jvm中的.class文件来进行操作的。.class文件中包含java类的所有信息，当你不知道某个类具体信息时，可以使用反射获取class，然后进行各种操作。

Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。总结说：反射就是把java类中的各种成分映射成一个个的Java对象，并且可以进行操作。

 

获取class的三种方式
先定义一个实体类Person：

Package reflex;
public class Person {
    //私有属性
    private String name = "Tom";

    //公有属性
    public int age = 18;
     
    //构造方法
    public Person() {   
     
    }
     
    //私有方法
    private void say(){
        System.out.println("private say()...");
    }
     
    //公有方法
    public void work(){
        System.out.println("public work()...");
    }
}
获取class方法 （类 对象 Class）
//1、对象调用 getClass() 方法来获取,通常应用在：比如你传过来一个 Object
//  类型的对象，而我不知道你具体是什么类，用这种方法
　　Person p1 = new Person();
　　Class c1 = p1.getClass();   

//2、类名.class 的方式得到,该方法最为安全可靠，程序性能更高
//  这说明任何一个类都有一个隐含的静态成员变量 class
　　Class c2 = Person.class;

//3、通过 Class 对象的 forName() 静态方法来获取，用的最多，
//   但可能抛出 ClassNotFoundException 异常
　　Class c3 = Class.forName("reflex.Person");

需要注意的是：一个类在 JVM 中只会有一个 Class 实例,即我们对上面获取的 c1,c2,c3进行 equals 比较，发现都是true。代码如下：

        Class class1 = Person.class;
        Person person = new Person();
        Class class2= person.getClass();
        if(class1.equals(class2)){
            System.out.println("class1.equals(class2)");
        }
Class具有的部分方法如下：     

     getName()：获得类的完整名字。
　　getFields()：获得类的public类型的属性。
　　getDeclaredFields()：获得类的所有属性。包括private 声明的和继承类
　　getMethods()：获得类的public类型的方法。
　　getDeclaredMethods()：获得类的所有方法。包括private 声明的和继承类
　　getMethod(String name, Class[] parameterTypes)：获得类的特定方法，name参数指定方法的名字，parameterTypes 参数指定方法的参数类型。
　　getConstructors()：获得类的public类型的构造方法。
　　getConstructor(Class[] parameterTypes)：获得类的特定构造方法，parameterTypes 参数指定构造方法的参数类型。
　　newInstance()：通过类的不带参数的构造方法创建这个类的一个对象。

Class能实现的功能
1判断对象属于哪个类

        Person person = new Person();
        Class class2= person.getClass();
        System.out.println("class2："+class2);
输出：class2：class reflect.Person


2获取类信息
        Class class1 = Person.class;
        Method[] methods = class1.getMethods();
        Method[] declaredMethods = class1.getDeclaredMethods();
        Field[] declaredFields = class1.getDeclaredFields();

3构建对象

        Person person = new Person();
        Class class2= person.getClass();
        Object o = class2.newInstance();
         //强转前先用instanceof判断
        if(o instanceof Person){
            ((Person) o).work();
        }

4动态执行方法
        Class class1 = Person.class;
        Method work = class1.getDeclaredMethod("work");
        Person person = new Person();
        work.invoke(person);

5动态操作属性
       Class class1 = Person.class;
        Person person = new Person();
        Field field = class1.getDeclaredField("age");
        //age默认值是18
        field.set(person,22);
        System.out.println(person.age);

6动态代理

可以参考：https://blog.csdn.net/h2604396739/article/details/83096696

jdk源码对反射的使用实例
LongAdder中，运用反射获取某属性的偏移值，方便Unsafe类直接获取某属性的值

// Unsafe mechanics Unsafe相关的初始化
private static final sun.misc.Unsafe UNSAFE;
private static final long valueOffset;
static {
    try {
        UNSAFE = sun.misc.Unsafe.getUnsafe();
        Class<?> ak = Cell.class;
        // 获取类中属性的偏移值
        valueOffset = UNSAFE.objectFieldOffset (ak.getDeclaredField("value"));
    } catch (Exception e) {
        throw new Error(e);
    }
}

final boolean cas(long cmp, long val) {
    return UNSAFE.compareAndSwapLong(this, valueOffset, cmp, val);
}

什么时候应该使用反射?
1）反射构建出无法直接访问的类:例如可以把完整的包+类名称放到properties中，java中获取，然后就可以根据这个配置获取class了,然后你就可以干很多事
Class.forName("name");
2）调用不可访问的方法
3）简化代码







？？？？？？？？？？？？？

整理一下，摘的文章



bravo1988  反射   https://www.zhihu.com/question/24304289/answer/694344906



？？？？？？？？？？？？？？？



1.5：public Object invoke(Object obj,Object…args)

1.4：public Object invoke(Object obj,Object[] args)

由于JDK1.4和1.5对invoke方法的处理有区别， 所以在反射类似于main(String[] args) 这种参数是数组的方法时需要特殊处理

启动Java程序的main方法的参数是一个字符串数组，即public static void main(String[] args)，通过反射方式来调用这个main方法时，如何为invoke方法传递参数呢？按jdk1.5的语法，整个数组是一个参数，而按jdk1.4的语法，数组中的每个元素对应一个参数，当把一个字符串数组作为参数传递给invoke方法时，javac会到底按照哪种语法进行处理呢？jdk1.5肯定要兼容jdk1.4的语法，会按jdk1.4的语法进行处理，即把数组打散成为若干个单独的参数。所以，在给main方法传递参数时，不能使用代码mainMethod.invoke(null,new String[]{“xxx”})，javac只把它当作jdk1.4的语法进行理解，而不把它当作jdk1.5的语法解释，因此会出现参数个数不对的问题。

上述问题的解决方法：

（1）mainMethod.invoke(null,new Object[]{new String[]{"xxx"}});

这种方式，由于你传的是一个数组的参数，所以为了向下兼容1.4的语法，javac遇到数组会给你拆开成多个参数，但是由于咱们这个Object[ ] 数组里只有一个元素值，所以就算它拆也没关系

（2）mainMethod.invoke(null,(Object)new String[]{"xxx"});

这种方式相当于你传的参数是一个对象，而不是数组，所以就算是按照1.4的语法它也不会拆，所以问题搞定

编译器会作特殊处理，编译时不把参数当作数组看待，也就不会数组打散成若干个参数了

对上边的描述进行一下总结：在反射方法时，如果方法的参数是一个数组，考虑到向下兼容问题，会按照JDK1.4的语法来对待（JVM会把传递的数组参数拆开，拆开就会报参数的个数不匹配的错误）
解决办法：防止JVM拆开你的数组
    方式一：把数组看做是一个Object对象
    方式二：重新构建一个Object数组，那个参数数组作为唯一的元素存在。

































？？？？？？？？？？？？下面这段话啥意思啊？？？？？？？？？？？

可以发现，Class类的构造器是私有的，我们无法手动new一个Class对象，只能由JVM创建。JVM在构造Class对象时，需要传入一个类加载器，然后才有我们上面分析的一连串加载、创建过程。



- Class.forName()方法

![image-20210401100727894](C:\Users\34893\AppData\Roaming\Typora\typora-user-images\image-20210401100727894.png)

反正还是类加载器去搞呗。



- newInstance()

<img src="C:\Users\34893\AppData\Roaming\Typora\typora-user-images\image-20210401100705527.png" alt="image-20210401100705527" style="zoom:50%;" />

也就是说，**newInstance()底层就是调用无参构造对象的newInstance()。**

所以，本质上Class对象要想创建实例，其实都是通过构造器对象。如果没有空参构造对象，就无法使用clazz.newInstance()，必须要获取其他有参的构造对象然后调用构造对象的newInstance()。

？？？？？？？？？？？？？？？？？？？？？？？







【拓展】类加载器



















反射(Reflection)
Java的反射是指程序在运行期可以利用Class类拿到一个对象的所有信息。

一个类有：成员变量、方法、构造方法、包等等信息，利用反射技术可以对一个类进行解剖，把个个组成部分映射成一个个对象。而解剖使用的就是Class类中的方法。所以首先获取到每一个类（字节码文件）对应的Class类型的实例，然后利用这个Class类型的实例获取到该实例对应的类的所有信息。

注意：这里的Class类型是一个名叫Class的类。它长这样：

public final class Class {
    private Class() {}
}
//构造方法是私有的，所以Class实例是JVM内部创建的，每加载一种class，JVM就为其创建一个Class类型的实例。
1
2
3
4
一、获取Class类
获取一个类的的Class实例有三种方法

直接通过一个class的静态变量class获取：

Class cls = String.class;
1
如果我们有一个实例变量，可以通过该实例变量提供的getClass()方法获取：

String s = "Hello";
Class cls = s.getClass();
1
2
如果知道一个class的完整类名，可以通过静态方法Class.forName()获取：

Class cls = Class.forName("java.lang.String");
1
**动态加载：**JVM在执行Java程序的时候，并不是一次性把所有用到的class全部加载到内存，而是第一次需要用到class时才加载。

二、获取字段
Class类提供了以下几个方法来获取字段：

Field getField(name)根据字段名获取某个public的field（包括父类）.
Field getDeclaredField(name)根据字段名获取当前类的某个field（不包括父类）
Field[] getFields()获取所有public的field（包括父类）
Field[] getDeclaredFields()获取当前类的所有field（不包括父类）
一个Field对象包含了一个字段的所有信息：

getName()：返回字段名称，例如，"name"；
getType()：返回字段类型，也是一个Class实例，例如，String.class；
getModifiers()：返回字段的修饰符，它是一个int，不同的bit表示不同的含义。
以String类的value字段为例，它的定义是：

public final class String {
    private final byte[] value;
}
1
2
3
我们用反射获取该字段的信息，代码如下：

Field f = String.class.getDeclaredField("value");
f.getName(); // "value"
f.getType(); // class [B 表示byte[]类型
int m = f.getModifiers();
Modifier.isFinal(m); // true
Modifier.isPublic(m); // false
Modifier.isProtected(m); // false
Modifier.isPrivate(m); // true
Modifier.isStatic(m); // false
1
2
3
4
5
6
7
8
9
获取字段值和设置字段值
利用反射拿到字段的一个Field实例只是第一步，我们还可以拿到一个实例对应的该字段的值，并且也可以设置该实例的字段值。

获取字段值是通过Field.get(Object)实现的，其中Object参数是指定的实例.

设置字段值是通过Field.set(Object, Object)实现的，其中第一个Object参数是指定的实例，第二个Object参数是待修改的值。

例如，对于一个Person实例，我们可以先拿到name字段对应的Field，再获取这个实例的name字段的值：

public class Main {
    public static void main(String[] args) throws Exception {
        Person p = new Person("Xiao Ming");
        Class c = p.getClass(); //通过实例变量p获取Person类的Class实例。
        Field f = c.getDeclaredField("name");   //获取当前类的name字段
        f.setAccessible(true);  //private需要更改字段的设置
        Object value = f.get(p);    //通过Field的实例f获取p实例的字段值。
        System.out.println(p.getName()); // "Xiao Ming"
        f.set(p, "Xiao Hong");  //设置字段值。
        System.out.println(p.getName()); // "Xiao Hong"
    }
}

class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }
    public String getName() {
        return this.name;
    }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
通过Field实例可以读取或设置某个对象的字段，如果存在访问限制，要首先调用setAccessible(true)来访问非public字段。

通过反射读写字段是一种非常规方法，它会破坏对象的封装。

三、获取方法
Class类提供了以下几个方法来获取Method：

Method getMethod(name, Class...)：获取某个public的Method（包括父类）
Method getDeclaredMethod(name, Class...)：获取当前类的某个Method（不包括父类）
Method[] getMethods()：获取所有public的Method（包括父类）
Method[] getDeclaredMethods()：获取当前类的所有Method（不包括父类）
Class...代表方法中形参的Class类型对象。

一个Method对象包含一个方法的所有信息：

getName()：返回方法名称，例如："getScore"；
getReturnType()：返回方法返回值类型，也是一个Class实例，例如：String.class；
getParameterTypes()：返回方法的参数类型，是一个Class数组，例如：{String.class, int.class}；
getModifiers()：返回方法的修饰符，它是一个int，不同的bit表示不同的含义。
调用方法
public class Main {
    public static void main(String[] args) throws Exception {
        // String对象:
        String s = "Hello world";
        // 获取String substring(int)方法，参数为int:
        Method m = String.class.getMethod("substring", int.class);
        // 在s对象上调用该方法并获取结果:
        String r = (String) m.invoke(s, 6);
        // 打印调用结果:
        System.out.println(r);
    }
}

1
2
3
4
5
6
7
8
9
10
11
12
13
对Method实例调用invoke就相当于调用该方法，invoke的第一个参数是对象实例，即在哪个实例上调用该方法，后面的可变参数要与方法参数一致，否则将报错。

调用静态方法
由于无需指定实例对象，所以invoke方法传入的第一个参数永远为null。

调用非public方法
我们虽然可以通过Class.getDeclaredMethod()获取该方法实例，但直接对其调用将得到一个IllegalAccessException。为了调用非public方法，我们通过Method.setAccessible(true)允许其调用。

四、获取构造方法
如果通过反射来创建新的实例，可以调用Class提供的newInstance()方法：

Person p = Person.class.newInstance();
1
调用Class.newInstance()的局限是，它只能调用该类的public无参数构造方法。

为了调用任意的构造方法，Java的反射API提供了Constructor对象，它包含一个构造方法的所有信息。

通过Class实例获取Constructor的方法如下：

getConstructor(Class...)：获取某个public的Constructor；
getDeclaredConstructor(Class...)：获取某个Constructor；
getConstructors()：获取所有public的Constructor；
getDeclaredConstructors()：获取所有Constructor。
调用非public的Constructor时，必须首先通过setAccessible(true)设置允许访问。

public class Main {
    public static void main(String[] args) throws Exception {
        // 获取构造方法Integer(int):
        Constructor cons1 = Integer.class.getConstructor(int.class);
        // 调用构造方法:
        Integer n1 = (Integer) cons1.newInstance(123);
        System.out.println(n1);

        // 获取构造方法Integer(String)
        Constructor cons2 = Integer.class.getConstructor(String.class);
        Integer n2 = (Integer) cons2.newInstance("456");
        System.out.println(n2);
    }
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
五、获取继承关系
通过Class对象可以获取继承关系：

Class getSuperclass()：获取父类类型；
Class[] getInterfaces()：获取当前类实现的所有接口。
过Class对象的isAssignableFrom()方法可以判断一个向上转型是否可以实现。











？？？？？？？？？？？？？？？？？？？？？？？？？？？？？



结合自己在IDEA上写的有关反射的代码









## 注解



格式

```
public @interface 注解名称{
	属性列表;
}
```



JDK注解

自定义注解

第三方框架注解



定义注解，使用注解，读取注解



注解编译得到字节码，经过反编译，可以看到

```java
public @interface TestAnnotation {}
|	[编译]
class（字节码）
|	[反编译]
public interface TestAnnotation extends Annotation{}
```



元注解（可理解为 “注解上的注解”）

```java
/*	仅取较为常用注解	*/

@Documented	//	用于制作文档

@Target	//	限定注解使用位置


@Rentention	//	保留策略
	RetentionPolicy. SOURCE/CLASS/RUNTIME
```



- 注解主要被反射读取
- 反射只能读取内存中的字节码信息
- RetentionPolicy.CLASS指的是保留到字节码文件，它在磁盘内，而不是内存中。虚拟机将字节码文件加载进内存后注解会消失
- 要想被反射读取，保留策略只能用RUNTIME，即运行时仍可读取

注解的读取并不只有反射一种途径。比如@Override，它由编译器读取（你写完代码ctrl+s时就编译了）保留策略为SOURCE



**属性的数据类型** 

- 八种基本数据类型
- String
- 枚举
- Class
- 注解类型
- 以上类型的一维数组

如果注解的属性只有一个，且叫value，那么使用该注解时，可以不用指定属性名





注解就像标签，是程序判断执行的依据。比如，程序读到@Test就知道这个方法是待测试方法，而@Before的方法要在测试方法之前执行



```java
package com.xj731231.annotation;

import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;

/**
 * 定义注解
 */
@Retention(RetentionPolicy.RUNTIME)
public @interface TestAnnotation {

    // 可以称之为属性
    String getKnowledge();
}
```

```java
package com.xj731231.annotation;

/**
 * Description: 使用注解
 * Author: jie.xu
 * Date: 2021/05/24
 */
public class Demo {

    @TestAnnotation(getKnowledge = "一个主义正不正确，要看他对人民好不好")
	//  ①  public String name = "资产阶级必将消亡";
    
    String name = "资产阶级必将消亡"; // ②
}

```

```java
package com.xj731231.annotation;

import java.lang.reflect.Field;

/**
 * Description: 读取注解
 * Author: jie.xu
 * Date: 2021/05/24
 */
public class TestDemo1 {

    public static void main(String[] args) throws Exception {

        /*
        这里name出现了NoSuchFieldException异常，我用两种方法解决了
        
        ① 将原来默认修饰符的 name 属性，改为了 public；这时可以用getField
        ② 直接将获取字段的方法改为 getDeclaredField，此时，是否是 public 修饰，不重要了

        我自网上得到一段结论，暂不知真伪，但比较可信:
        Field getField(name)：根据字段名获取某个public的field（包括父类）
        Field getDeclaredField(name)：根据字段名获取当前类的某个field（不包括父类）
        Field[] getFields()：获取所有public的field（包括父类） 
        Field[] getDeclaredFields()：获取当前类的所有field（不包括父类）
         */


		//  ①   Field name = Demo1.class.getField("name");
        
        Field name = Demo1.class.getDeclaredField("name"); // ②


		// 这里保存策略选择了RUNTIME，反射才能识别到，之前用默认，annotation 为 null
        TestAnnotation annotation = name.getAnnotation(TestAnnotation.class);

        System.out.println(annotation.getKnowledge());
        System.out.println(name);
    }
}
```





================================================================================



```java
package com.xj731231.annotation;

import java.lang.reflect.ParameterizedType;
import java.lang.reflect.Type;

/**
 * Description: 父类
 * Author: jie.xu
 * Date: 2021/05/25
 */
public class A<T> {

    public A () {
        Class cls = this.getClass();
        System.out.println(cls);// class com.xj731231.annotation.B
        // 得到 cls 父类（参数化类型）
        Type type = cls.getGenericSuperclass();
        System.out.println(type);// com.xj731231.annotation.A<java.lang.String>
        // 之前所得为参数化类型，向下强转
        ParameterizedType superclass = (ParameterizedType) type;
        System.out.println(superclass);// com.xj731231.annotation.A<java.lang.String>
        // 获取所有泛型参数的Class对象
        Type[] types = superclass.getActualTypeArguments();
        // 由于A只有一个泛型，直接取第一个，即为T的Class对象
        Class act =(Class) types[0];
        System.out.println(act);// class java.lang.String
        // 实现了在父类中得到子类继承时传来的泛型的 Class 对象
    }
}
```

```java
package com.xj731231.annotation;

/**
 * Description: 子类
 * Author: jie.xu
 * Date: 2021/05/25
 */
public class B extends A<String> {
}
```

```java
package com.xj731231.annotation;

/**
 * Description: 观察父子类的继承等
 * Author: jie.xu
 * Date: 2021/05/25
 */
public class Test {

    /*
    ArrayList<E> 中的 E 称为类型参数变量
    ArrayList<Integer> 中的 Integer 称为实际类型参数
    整个 ArrayList<E> 称为泛型类型
    整个 ArrayList<Integer> 称为参数化的类型 ParameterizedType
     */

    public static void main(String[] args) {
        new B();
        /*
        先进入B的构造方法，进入父类A的，执行 this.getClass();
        由于自始至终只初始化了一个对象B，故

        System.out.println(cls) 的打印结果为：
        class com.xj731231.annotation.B

        System.out.println(type) 的打印结果为：
        com.xj731231.annotation.A<java.lang.String>
         */
    }
}
```























？？？？？？？？？？？

看链接文章，总结归纳，不可复制的













？？？？？？？？？？？？？？







### 一、什么是注解？

注解：Annotation….

注解其实就是**代码中的特殊标记**，这些标记可以**在编译、类加载、运行时被读取，并执行相对应的处理**。

### 二、为什么我们需要用到注解？

传统的方式，我们是通过**配置文件(xml文件)来告诉类是如何运行的**。

有了注解技术以后，我们就可以**通过注解告诉类如何运行**

例如：我们以前编写Servlet的时候，需要在web.xml文件配置具体的信息

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD4KXwp4Kb9376yh3P0lnBEsFeDM0kxZh2SGiaV6S80Paf1ia9vbntC0mSg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述

我们使用了注解以后，可以直接在Servlet源代码上，增加注解…Servlet就被配置到Tomcat上了。也就是说，**注解可以给类、方法上注入信息。**

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD4heluVq2WiaWhv5VRnFWhsl2pMMae958bZPmh42oZGsMg2FpOJvWCSHQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述

明显地可以看出，这样是非常直观的，并且**Servlet规范是推崇这种配置方式的**。

### 三、基本Annotation

在java.lang包下存在着5个基本的Annotation，其中有3个Annotation我们是非常常见的了。

#### 3.1@Override

**重写注解**

如果我们使用IDE重写父类的方法，我们就可以看见它了。那它有什么用呢？？

@Overried是告诉编译器要检查**该方法是实现父类的**…可以帮我们避免一些低级的错误…

比如，我们在实现equals()方法的时候，把euqals()打错了，那么**编译器就会发现该方法并不是实现父类的，与注解@Override冲突，于是就会给予错误**。

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD41OEF5xHxngBF8hJPReH2Lalhn6TWLhLnDtrpVvRMTnwc9XF7l3ibLmQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述



------

#### 3.2@Deprecated

**过时注解**

该注解也非常常见，Java在设计的时候，可能觉得某些方法设计得不好，**为了兼容以前的程序，是不能直接把它抛弃的，于是就设置它为过时**。

Date对象中的toLocalString()就被设置成过时了

```
    @Deprecated
    public String toLocaleString() {
        DateFormat formatter = DateFormat.getDateTimeInstance();
        return formatter.format(this);
    }
```

当我们在程序中调用它的时候，在IDE上会出现一条横杠，说明该方法是过时的。

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD4qQzO2ghINsw3bDc6ctB2wrdPuIB51WicjIHQdeTYQsSibxlXQliaztoPw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述

------

#### 3.3@SuppressWarnings

**抑制编译器警告注解**

该注解在我们写程序的时候并不是很常见，我们可以用它来**让编译器不给予我们警告**

当我们在使用集合的时候，如果没有指定泛型，那么会提示安全检查的警告

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD4B2d3ibDuP4TTxXgzUyqL2KKkrJRic66reibum8KwJ2T6oRQ62icoj0RQcA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述

如果我们在类上添加了@SuppressWarnings这个注解，那么编译器就不会给予我们警告了

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD4RRyU8PxXDmK36uh1tGu4AvF2WSaeEguF81QHd2asL1UHUx1Equ33HQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述

#### 3.4@SafeVarargs

**Java 7“堆污染”警告**

什么是堆污染呢？？**当把一个不是泛型的集合赋值给一个带泛型的集合的时候**，这种情况就很容易发生堆污染….

这个注解也是用来抑制编译器警告的注解…用的地方并不多，我也不详细说明了……有用到的时候再回来填坑吧。

#### 3.5@FunctionalInterface

**@FunctionalInterface用来指定该接口是函数式接口**

用该注解**显示指定**该接口是一个函数式接口。

------

### 四、自定义注解基础

上面讲解的是java.lang包下的5个注解，**我们是可以自己来写注解，给方法或类注入信息**。

#### 4.1标记Annotation

**没有任何成员变量的注解称作为标记注解，@Overried就是一个标记注解**

```
//有点像定义一个接口一样，只不过它多了一个@
public @interface MyAnnotation {

}
```

#### 4.2元数据Annotation

**我们自定义的注解是可以带成员变量的，定义带成员变量的注解叫做元数据Annotation**

在注解中定义成员变量，**语法类似于声明方法一样**….

```
public @interface MyAnnotation {

    //定义了两个成员变量
    String username();
    int age();
}
```

注意：在注解上**定义的成员变量只能是String、数组、Class、枚举类、注解**

有的人可能会奇怪，为什么注解上还要定义注解成员变量？？听起来就很复杂了….

上边已经说了，注解的作用就是给类、方法注入信息。那么我们经常使用XML文件，告诉程序怎么运行。**XML经常会有嵌套的情况**

```
<书>
    <作者>zhongfucheng</作者>
    <价钱>22222</价钱>

</书>
```

那么，当我们在使用注解的时候，也可能需要有嵌套的时候，所以就**允许了注解上可以定义成员变量为注解。**

#### 4.3使用自定义注解

上面我们已经定义了一个注解了，下面我们来使用它吧

##### 4.3.1常规使用

下面我有一个add的方法，需要username和age参数，我们**通过注解来让该方法拥有这两个变量**！

```
    //注解拥有什么属性，在修饰的时候就要给出相对应的值
    @MyAnnotation(username = "zhongfucheng", age = 20)
    public void add(String username, int age) {

    }
```

------

##### 4.3.2默认值

当然啦，我们可以在**注解声明属性的时候，给出默认值**。那么在修饰的时候，就可以不用具体指定了。

```
public @interface MyAnnotation {

    //定义了两个成员变量
    String username() default "zicheng";
    int age() default 23;
}
```

- 在修饰的时候就不需要给出具体的值了

```
    @MyAnnotation()
    public void add(String username, int age) {

    }
```

------

##### 4.3.3注解属性为value

还有一种特殊的情况，如果**注解上只有一个属性，并且属性的名称为value**，那么在使用的时候，我们**可以不写value，直接赋值给它就行**

```
public @interface MyAnnotation2 {

    String value();
}
```

- 使用注解，可以**不指定value，直接赋值**

```
    @MyAnnotation2("zhongfucheng")
    public void find(String id) {

    }
```

------

#### 4.4把自定义注解的基本信息注入到方法上

上面我们已经使用到了注解，但是目前为止**注解上的信息和方法上的信息是没有任何关联的**。

我们使用Servlet注解的时候，仅仅调用注解，那么注解的就生效了。这是**Web容器把内部实现了**。我们**自己写的自定义注解是需要我们自己来处理的**。

那现在问题来了，我们怎么把注解上的信息注入到方法上呢？？？我们**利用的是反射技术**

步骤可分为三部：

- **反射出该类的方法**
- **通过方法得到注解上具体的信息**
- **将注解上的信息注入到方法上**

```
        //反射出该类的方法
        Class aClass = Demo2.class;
        Method method = aClass.getMethod("add", String.class, int.class);

        //通过该方法得到注解上的具体信息
        MyAnnotation annotation = method.getAnnotation(MyAnnotation.class);
        String username = annotation.username();
        int age = annotation.age();

        //将注解上的信息注入到方法上
        Object o = aClass.newInstance();
        method.invoke(o, username, age);
```

当我们执行的时候，我们发现会出现异常…

![这里写图片描述](https://mmbiz.qpic.cn/mmbiz_png/2BGWl1qPxib0M72HubI1a9Biaib8ycykoD45BmERyxNS5tVo91ficiczuw3Ns6OVPpqljaQtHRwIHHJt9GYjibukr2KA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)这里写图片描述

此时，我们需要在自定义注解上加入这样一句代码**(下面就会讲到，为什么要加入这句代码)**

```
    @Retention(RetentionPolicy.RUNTIME)
```

再次执行的时候，我们就会发现，可以通过注解来把信息注入到方法中了。

------

### 五、JDK的元Annotation

前面我们已经介绍了java.lang包下的几个基本Annotation了。在JDK中除了java.lang包下有Annotation，**在java.lang.annotation下也有几个常用的元Annotation。**

在annotation包下的好几个元Annotation都是**用于修饰其他的Annotation定义**。

------

#### 5.1@Retention

上面在将注解信息注入到方法中的时候，我们**最后加上了@Retention的注解….不然就会报错了**..那它是干什么用的呢？

@Retention只能用于修饰其他的Annotation，**用于指定被修饰的Annotation被保留多长时间。**

@Retention **包含了一个RetentionPolicy类型的value变量**，所以在使用它的时候，**必须要为value成员变量赋值**

value变量的值只有三个：

```
public enum RetentionPolicy {
    /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME
}
```

java文件有三个时期：**编译,class,运行。@Retention默认是class**

前面我们是使用反射来得到注解上的信息的，**因为@Retention默认是class，而反射是在运行时期来获取信息的**。因此就获取不到Annotation的信息了。于是，就得在自定义注解上修改它的RetentionPolicy值

------

#### 5.2@Target

@Target也是**只能用于修饰另外的Annotation**，**它用于指定被修饰的Annotation用于修饰哪些程序单元**

@Target是只有一个value成员变量的，该成员变量的值是以下的：

```
public enum ElementType {
    /** Class, interface (including annotation type), or enum declaration */
    TYPE,

    /** Field declaration (includes enum constants) */
    FIELD,

    /** Method declaration */
    METHOD,

    /** Parameter declaration */
    PARAMETER,

    /** Constructor declaration */
    CONSTRUCTOR,

    /** Local variable declaration */
    LOCAL_VARIABLE,

    /** Annotation type declaration */
    ANNOTATION_TYPE,

    /** Package declaration */
    PACKAGE
}
```

如果@Target指定的是ElementType.ANNOTATION_TYPE，那么**该被修饰的Annotation只能修饰Annotaion**

------

#### 5.3@Documented

@Documented用于指定**被该Annotation修饰的Annotation类将被javadoc工具提取成文档**。

该元Annotation用得挺少的….

------

#### 5.4@Inherited

@Inherited也是用来修饰其他的Annotation的，被修饰过的Annotation将具有继承性。。。

例子：

1. @xxx是我自定义的注解，我现在使用@xxx注解在Base类上使用….
2. 使用@Inherited修饰@xxx注解
3. 当有类继承了Base类的时候，该实现类自动拥有@xxx注解

------

### 六、注入对象到方法或成员变量上

#### 6.1把对象注入到方法上

前面我们已经可以使用注解将基本的信息注入到方法上了，现在我们要使用的是**将对象注入到方法上**…..

上边已经说过了，注解上只能定义String、枚举类、Double之类的成员变量，那怎么把对象注入到方法上呢？

##### 6.1.2模拟场景：

- Person类，定义username和age属性，拥有uername和age的getter和setter方法

```
public class Person {

    private String username;
    private int age;

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }
}
```

- PersonDao类，PersonDao类定义了Person对象，拥有person的setter和getter方法

```
public class PersonDao {

    private Person person;

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {
        this.person = person;
    }
}
```

- 现在我要做的就是：**使用注解将Person对象注入到setPerson()方法中，从而设置了PersonDao类的person属性**

```
public class PersonDao {

    private Person person;

    public Person getPerson() {
        return person;
    }


    //将username为zhongfucheng，age为20的Person对象注入到setPerson方法中
    @InjectPerson(username = "zhongfucheng",age = 20)
    public void setPerson(Person person) {

        this.person = person;
    }
}
```

------

**步骤：**

①： 自定义一个注解，属性是和JavaBean类一致的

```
//注入工具是通过反射来得到注解的信息的，于是保留域必须使用RunTime
@Retention(RetentionPolicy.RUNTIME)
public @interface InjectPerson {

    String username();
    int age();
}
```

②：编写注入工具

```
        //1.使用内省【后边需要得到属性的写方法】，得到想要注入的属性
        PropertyDescriptor descriptor = new PropertyDescriptor("person", PersonDao.class);

        //2.得到要想注入属性的具体对象
        Person person = (Person) descriptor.getPropertyType().newInstance();

        //3.得到该属性的写方法【setPerson()】
        Method method = descriptor.getWriteMethod();

        //4.得到写方法的注解
        Annotation annotation = method.getAnnotation(InjectPerson.class);

        //5.得到注解上的信息【注解的成员变量就是用方法来定义的】
        Method[] methods = annotation.getClass().getMethods();

        //6.将注解上的信息填充到person对象上

        for (Method m : methods) {

            //得到注解上属性的名字【age或name】
            String name = m.getName();

            //看看Person对象有没有与之对应的方法【setAge(),setName()】
            try {

                //6.1这里假设：有与之对应的写方法，得到写方法
                PropertyDescriptor descriptor1 = new PropertyDescriptor(name, Person.class);
                Method method1 = descriptor1.getWriteMethod();//setAge(), setName()

                //得到注解中的值
                Object o = m.invoke(annotation, null);

                //调用Person对象的setter方法，将注解上的值设置进去
                method1.invoke(person, o);

            } catch (Exception e) {

                //6.2 Person对象没有与之对应的方法，会跳到catch来。我们要让它继续遍历注解就好了
                continue;
            }
        }

        //当程序遍历完之后，person对象已经填充完数据了

        //7.将person对象赋给PersonDao【通过写方法】
        PersonDao personDao = new PersonDao();
        method.invoke(personDao, person);

        System.out.println(personDao.getPerson().getUsername());
        System.out.println(personDao.getPerson().getAge());
```

③：总结一下步骤

其实我们是这样把对象注入到方法中的：

- 得到想要类中注入的属性
- 得到该属性的对象
- 得到属性对应的写方法
- 通过写方法得到注解
- 获取注解详细的信息
- 将注解的信息注入到对象上
- 调用属性写方法，将已填充数据的对象注入到方法中

------

#### 6.2把对象注入到成员变量

上面已经说了如何将对象注入到方法上了，那么注入到成员变量上也是非常简单的。

**步骤：**

①：**在成员变量上使用注解**

```
public class PersonDao {

    @InjectPerson(username = "zhongfucheng",age = 20) private Person person;

    public Person getPerson() {
        return person;
    }

    public void setPerson(Person person) {

        this.person = person;
    }
}
```

②：编写注入工具

```
        //1.得到想要注入的属性
        Field field = PersonDao.class.getDeclaredField("person");

        //2.得到属性的具体对象
        Person person = (Person) field.getType().newInstance();

        //3.得到属性上的注解
        Annotation annotation = field.getAnnotation(InjectPerson.class);

        //4.得到注解的属性【注解上的属性使用方法来表示的】
        Method[] methods = annotation.getClass().getMethods();

        //5.将注入的属性填充到person对象上
        for (Method method : methods) {

            //5.1得到注解属性的名字
            String name = method.getName();

            //查看一下Person对象上有没有与之对应的写方法
            try {

                //如果有
                PropertyDescriptor descriptor = new PropertyDescriptor(name, Person.class);

                //得到Person对象上的写方法
                Method method1 = descriptor.getWriteMethod();

                //得到注解上的值
                Object o = method.invoke(annotation, null);

                //填充person对象
                method1.invoke(person, o);
            } catch (IntrospectionException e) {

                //如果没有想对应的属性，继续循环
                continue;
            }
        }

        //循环完之后，person就已经填充好数据了


        //6.把person对象设置到PersonDao中
        PersonDao personDao = new PersonDao();
        field.setAccessible(true);
        field.set(personDao, person);

        System.out.println(personDao.getPerson().getUsername());
```

#### 七、总结

①：注入对象的步骤：**得到想要注入的对象属性，通过属性得到注解的信息，通过属性的写方法将注解的信息注入到对象上，最后将对象赋给类**。

②：注解其实就是两个作用：

- **让编译器检查代码**
- **将数据注入到方法、成员变量、类上**

③:在JDK中注解分为了

- 基本Annotation

- - 在lang包下，用于常用于标记该方法，抑制编译器警告等

- 元Annotaion

- - 在annotaion包下，常用于修饰其他的Annotation定义



### 注解代替web.xml



##### 一种写法





配置Servlet类
web.xml配置方法

```
  <servlet>
    <servlet-name>servlet的名字</servlet-name>
    <servlet-class>servlet的路径</servlet-class>
    <init-param>
        <param-name>初始化参数名字</param-name>
        <param-value>初始化参数值</param-value>
    </init-param>
  </servlet>
  <servlet-mapping>
    <servlet-name>servlet的名字</servlet-name>
    <url-pattern>/发布到服务器的名字</url-pattern>
  </servlet-mapping>123456789101112
    // 注解源代码
public @interface WebServlet {

    String name() default "";  // Servlet的名称

    String[] value() default {}; // 发布到服务器的名字 多个 与 urlPatterns 不共存

    String[] urlPatterns() default {};// 发布到服务器的名字

    int loadOnStartup() default -1; // 当值为0或者大于0时，表示容器在应用启动时就加载这个servlet;当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。(默认为 -1 ) 在类加载时创建 

    WebInitParam[] initParams() default {}; // 初始化参数 name - value - description 调用方法通过name获取value 

    boolean asyncSupported() default false; //  申明servlet是否支持异步操作模式(默认不支持)

    String smallIcon() default ""; // Servlet的小图标

    String largeIcon() default ""; // Servlet的大图标

    String description() default ""; // servlet类描述

    String displayName() default ""; // Servlet的名字 
}
123456789101112131415161718192021222324
@WebServlet(
        urlPatterns = { "/发布到服务器的名字" }, 
        initParams = { 
                @WebInitParam(name = "名称", value = "值", description = "描述")
        })12345
```



注解 -> web,xml 互换



| 属性名         | xml中用于替换标签  |
| -------------- | ------------------ |
| name           | < servlet-name >   |
| value          | 等价于 urlPatterns |
| urlPatterns    | < url-pattern>     |
| loadOnStartup  | < load-on-startup> |
| initParams     | < init-param>      |
| asyncSupported | < async-supported> |
| displayName    | < display-name>    |
| description    | < description>     |











##### 另一种写法





```
/**
 * Created by buer on 2018/4/9.
 */
@WebServlet(name = "Servlet2",urlPatterns = "/onee")
 
public class Servlet2 extends HttpServlet {
    protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
        doGet(request, response);
    }
 
    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
 
        PrintWriter  out = response.getWriter();
        out.print("2333333333");
        String name = request.getParameter("name1");
        out.print(name);
    }
}
```



##### 再一种写法



首先我们压迫了解一个机制（不是机智），Servlet注解技术：

@WebServlet  取代servlet配置
@WebFilter    取代filter配置
@WebInitParam   取代初始化参数配置（servlet、filter）
@WebListener    取代listener配置



然后我们来看看注解后的代码：



```java
@WebServlet(urlPatterns={"/one","/two"})//{}里可以设置多个servlet名

public class HelloServlet extends HttpServlet 
{

	public void doGet(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
	{
		response.getWriter().print("I am Annotation servlet build by 参与感");
	}

	public void doPost(HttpServletRequest request, HttpServletResponse response)
			throws ServletException, IOException 
	{

		doGet(request, response);

	}

}
```



```java
@WebFilter(urlPatterns="/*")//多个servlet要拦截的话，加*

public class EncodingFilter implements Filter {

	public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) 			throws IOException, ServletException {
		//编码
		response.setContentType("text/html;charset=utf-8");
		chain.doFilter(request, response);
	}

	public void init(FilterConfig fConfig) throws ServletException {

	}

	@Override
	public void destroy() {

	}

}
```



















## I/O







## 图形化（如Swing）











































































































































































































































































































































































































































































































































































































































































































































### 参考文章

**图片素材来源  站酷 - 蒸汽工场   https://www.zcool.com.cn/work/ZNTEwNTI0NDQ=.html**

**懒懒惰惰一只猫  java关键字之return关键字   https://www.cnblogs.com/lanmao123/p/10489600.html**



**力扣（LeetCode）  如何学习设计模式   https://www.zhihu.com/question/308850392/answer/1324509357**

**阿里云云栖号  Java Map 中那些巧妙的设计   https://zhuanlan.zhihu.com/p/360089584**

**代码随想录  算法精讲   https://github.com/youngyangyang04/leetcode-master**



**嗑嗑磕嗑瓜子的猫  用最直接的大白话来聊一聊Java中的反射机制   https://blog.csdn.net/ju_362204801/article/details/90578678**

**bravo1988  浅谈反射机制   https://zhuanlan.zhihu.com/p/66853751**

**请叫我程序猿大人  好怕怕的类加载器   https://zhuanlan.zhihu.com/p/54693308**

**bravo1988  反射   https://www.zhihu.com/question/24304289/answer/694344906**

**peter_RD_nj  Java高级特性——反射   https://www.jianshu.com/p/9be58ee20dee**

**leevmh  Java的反射   https://blog.csdn.net/qq_42537795/article/details/106017092**



**深山猿  java反射的原理，作用   https://blog.csdn.net/h2604396739/article/details/83109292**



**时间沉淀美好  Annotation(注解)代替web.xml完成servlet配置   https://blog.csdn.net/u012881836/article/details/51236488**

**changzhiqiang_  web.xml与注解配置servlet使用介绍   https://blog.csdn.net/crpxnmmafq/article/details/76946316?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-4.add_param_isCf**

**Java3y  注解就是这么简单   https://mp.weixin.qq.com/s?__biz=MzI4Njg5MDA5NA==&mid=2247484113&idx=1&sn=f5fd35b2f7dc45a256fee170cad0cdc9&chksm=ebd743d0dca0cac6a8fed8caf09f0d561b0358dece9b8e746e1e6726bca093287cf515638349&scene=21###wechat_redirect**

**bravo 1988  注解（下）   https://zhuanlan.zhihu.com/p/60966151**













































